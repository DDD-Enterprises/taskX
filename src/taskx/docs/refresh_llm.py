"""Deterministic LLM docs autogen refresh for TaskX command surface."""

from __future__ import annotations

import hashlib
import json
from dataclasses import dataclass
from pathlib import Path
from typing import TYPE_CHECKING, Any

if TYPE_CHECKING:
    import typer

AUTOGEN_START = "<!-- TASKX:AUTOGEN:START -->"
AUTOGEN_END = "<!-- TASKX:AUTOGEN:END -->"
TARGET_FILES: tuple[str, ...] = ("AGENTS.md", "CLAUDE.md", "CODEX.md")
REPORT_DIR = Path("out/taskx_docs_refresh_llm")
REPORT_JSON = "DOCS_REFRESH_LLM_REPORT.json"
REPORT_MD = "DOCS_REFRESH_LLM_REPORT.md"


class MarkerStructureError(RuntimeError):
    """Raised when AUTOGEN marker structure is invalid."""


@dataclass(frozen=True)
class RefreshResult:
    """Deterministic refresh result summary."""

    created: tuple[str, ...]
    modified: tuple[str, ...]
    unchanged: tuple[str, ...]
    refused: tuple[str, ...]
    command_surface_hash: str
    block_content: str


def refresh_llm_docs(*, repo_root: Path, cli_app: typer.Typer, check: bool = False) -> RefreshResult:
    """Refresh LLM docs marker blocks from internal command registry."""
    resolved_repo = repo_root.resolve()
    surface = extract_command_surface(cli_app)
    block_content = render_autogen_block(surface)
    block_hash = hashlib.sha256(block_content.encode("utf-8")).hexdigest()

    created: list[str] = []
    modified: list[str] = []
    unchanged: list[str] = []
    refused: list[str] = []

    for name in TARGET_FILES:
        path = resolved_repo / name
        current_text = path.read_text(encoding="utf-8") if path.exists() else ""

        try:
            next_text, state = apply_autogen_update(current_text, block_content)
        except MarkerStructureError:
            refused.append(name)
            continue

        if state == "created":
            created.append(name)
        elif state == "modified":
            modified.append(name)
        else:
            unchanged.append(name)

        if not check and next_text != current_text:
            path.write_text(next_text, encoding="utf-8")

    result = RefreshResult(
        created=tuple(sorted(created)),
        modified=tuple(sorted(modified)),
        unchanged=tuple(sorted(unchanged)),
        refused=tuple(sorted(refused)),
        command_surface_hash=block_hash,
        block_content=block_content,
    )

    write_refresh_report(repo_root=resolved_repo, result=result, check=check)
    return result


def extract_command_surface(cli_app: typer.Typer) -> dict[str, Any]:
    """Extract deterministic command surface from Typer registry."""
    top_level = sorted(_command_names(cli_app) | _group_names(cli_app))

    groups: dict[str, list[str]] = {}
    for group_name in ("project", "route", "docs", "pr"):
        subapp = _find_group_app(cli_app, group_name)
        if subapp is None:
            continue
        subcommands = sorted(_command_names(subapp) | _group_names(subapp))
        if subcommands:
            groups[group_name] = subcommands

    return {
        "top_level": top_level,
        "groups": groups,
    }


def render_autogen_block(surface: dict[str, Any]) -> str:
    """Render stable markdown block for marker injection."""
    top_level: list[str] = surface["top_level"]
    groups: dict[str, list[str]] = surface["groups"]

    lines: list[str] = [
        "## TaskX Command Surface (Autogenerated)",
        "",
        "### Top-Level Commands",
    ]
    lines.extend(f"- {name}" for name in top_level)

    for section in ("project", "route", "docs", "pr"):
        if section not in groups:
            continue
        lines.extend(["", f"### {section}"])
        lines.extend(f"- {name}" for name in groups[section])

    lines.extend(["", "Generated by: taskx docs refresh-llm"])
    return "\n".join(lines)


def apply_autogen_update(text: str, block_content: str) -> tuple[str, str]:
    """Apply strict marker replacement and return new text + state."""
    marker_state = validate_marker_structure(text)
    block = f"{AUTOGEN_START}\n{block_content}\n{AUTOGEN_END}"

    if marker_state == "missing":
        normalized = text
        if normalized and not normalized.endswith("\n"):
            normalized += "\n"
        updated = f"{normalized.rstrip()}\n\n{block}\n" if normalized.strip() else f"{block}\n"
        return updated, "created"

    assert marker_state == "valid"
    start_index = text.find(AUTOGEN_START)
    end_index = text.find(AUTOGEN_END, start_index + len(AUTOGEN_START))
    assert start_index >= 0 and end_index >= 0
    end_index += len(AUTOGEN_END)

    updated = f"{text[:start_index]}{block}{text[end_index:]}"
    if updated == text:
        return text, "unchanged"
    return updated, "modified"


def validate_marker_structure(text: str) -> str:
    """Validate marker structure and return marker state."""
    start_count = text.count(AUTOGEN_START)
    end_count = text.count(AUTOGEN_END)

    if start_count == 0 and end_count == 0:
        return "missing"

    if start_count != 1 or end_count != 1:
        raise MarkerStructureError("Invalid AUTOGEN marker structure")

    start_index = text.find(AUTOGEN_START)
    end_index = text.find(AUTOGEN_END)
    if start_index > end_index:
        raise MarkerStructureError("Invalid AUTOGEN marker structure")

    return "valid"


def write_refresh_report(*, repo_root: Path, result: RefreshResult, check: bool) -> None:
    """Write deterministic JSON and markdown reports."""
    out_dir = repo_root / REPORT_DIR
    out_dir.mkdir(parents=True, exist_ok=True)

    payload = {
        "check_mode": check,
        "created": list(result.created),
        "modified": list(result.modified),
        "unchanged": list(result.unchanged),
        "refused": list(result.refused),
        "command_surface_hash": result.command_surface_hash,
    }

    (out_dir / REPORT_JSON).write_text(json.dumps(payload, indent=2, sort_keys=True), encoding="utf-8")

    lines = [
        "# DOCS_REFRESH_LLM_REPORT",
        "",
        f"- check_mode: {check}",
        f"- command_surface_hash: {result.command_surface_hash}",
        f"- created: {', '.join(result.created) if result.created else 'none'}",
        f"- modified: {', '.join(result.modified) if result.modified else 'none'}",
        f"- unchanged: {', '.join(result.unchanged) if result.unchanged else 'none'}",
        f"- refused: {', '.join(result.refused) if result.refused else 'none'}",
        "",
    ]
    (out_dir / REPORT_MD).write_text("\n".join(lines), encoding="utf-8")


def _find_group_app(cli_app: typer.Typer, group_name: str) -> typer.Typer | None:
    for group_info in cli_app.registered_groups:
        name = (group_info.name or "").strip()
        if name == group_name:
            return group_info.typer_instance
    return None


def _command_names(app: typer.Typer) -> set[str]:
    names: set[str] = set()
    for command in app.registered_commands:
        if command.hidden:
            continue
        name = command.name or command.callback.__name__.replace("_", "-")
        cleaned = name.strip()
        if cleaned:
            names.add(cleaned)
    return names


def _group_names(app: typer.Typer) -> set[str]:
    names: set[str] = set()
    for group in app.registered_groups:
        if group.hidden:
            continue
        name = (group.name or "").strip()
        if name:
            names.add(name)
    return names
